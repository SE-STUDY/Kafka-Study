# Kafka-Study

# 3.1 카프카 기초 다지기
카프카 구성 요소 정리
* 주키퍼(ZooKeeper) : 아파치 프로젝트 애플리케이션 명. 카프카 메타데이터 관리 or 브로커 health check 담당
* 카프카(Kafka) or 카프카 클러스터(Kafka Cluster) : 아파치 프로젝트 애플리케이션 명. 여러 대의 브로커를 구성한 클러스터
* 브로커(broker) : 카프카 애플리케이션이 설치된 서버 또는 노드
* 프로듀서(producer) : 카프카로 메시지 보내는 클라이언트
* 컨슈머(consumer) : 카프카에서 메시지를 꺼내는 클라이언트
* 토픽(topic) : 카프카는 메시지 피드를 토픽으로 구분, 토픽명은 카프카에서 고유하다.
* 파티션(partition) : 병렬 처리 및 고성능을 위해 하나의 토픽을 여러 개로 나눔
* 세그먼트(segment) : 프로듀서가 전송한 실제 메시지가 브로커의 로컬 디스크에 저장되는 파일
* 메시지(message) or 레코드(record) : 프로듀서 -> 브로커 전송 or 컨슈머가 읽는 데이터 조각

토픽은 PK마냥 유일

## 3.1.1 리플리케이션
메시지를 여러 개로 복제해서 카프카 클러스터 내 브로커들에 분산시키는 동작
-> 브로커가 종료되어도 안정성 유지 가능

![](https://velog.velcdn.com/images/tngh147258/post/17524464-54fc-4ec2-9a49-6f0d19d47652/image.png)
출처 : https://blog.ippon.tech/event-driven-architecture-getting-started-with-kafka-part-2/

실제로 토픽 자체가 리플리케이션이 되는 것이 아닌 토픽의 파티션이 피플리케이션이 되는 것

운영에서 리플리케이션은 3으로 진행. 그 이상은 안정성은 높지만 브로커 리소스를 많이 먹게 된다.

- 책에서 권장하는 리플리케이션 팩터
테스트 or 개발 : 리플리케이션 팩터 1개
운영 (로그성 메시지 or 약간 유실 허용) : 리플리케이션 팩터 2개
운영 (유실 허용 X) : 리플리케이션 팩터 3개

## 3.1.2 파티션
하나의 토픽이 한 번에 처리할 수 있는 한계를 높이기 위해 토픽 하나를 여러 개로 나눠 병렬처리가 가능하게 만든 것

이렇게 나눈 파티션 수만큼 컨슈머를 연결할 수 있다.

![](https://velog.velcdn.com/images/tngh147258/post/1b0ef28e-47ce-4c62-8d61-58972455cc4a/image.png)
출처 : https://blog.devgenius.io/kafka-producers-consumers-partitions-89229e675f5f

* 파티션 번호는 0부터 시작

* 참고용 적절한 파티션 수를 계산해주는 사이트
https://eventsizer.io

파티션 문제
소수 -> 다수 (O)
다수 -> 소수 (X)
늘리는 건 가능해도 줄이는 건 안된다. 작게 2 or 4정도로 세팅 후 메시지 처리량 or 컨슈머의 LAG등을 모니터링하면서 늘리는 걸 권장

* LAG : (넣는 데이터 > 가져가는 데이터) 데이터 차이
(접기)
프로듀서가 데이터를 넣는 속도가 컨슈머가 가져가는 속도보다 빠른 경우, 이때 생기는 프로듀서가 넣은 데이터의 오프셋과 컨슈머가 가져간 데이터의 오프셋의 차이 또는 토픽의 가장 최신 오프셋과 컨슈머 오프셋의 차이

## 3.1.3 세그먼트
각 메시지는 세그먼트라는 로그 파일 형태로 브로커의 로컬 디스크에 저장됨.


![](https://velog.velcdn.com/images/tngh147258/post/29765bd1-28f2-4dcd-a4a2-0d516ba6e247/image.png)
출처 : https://velog.io/@hyundong_kk/kafka-%EA%B8%B0%EC%B4%88-%EA%B0%9C%EB%85%90


### 정리
1. 프로듀서는 카프카의 토픽으로 메시지 전송
2. (토픽의 파티션이 하나의 경우) 프로듀서로 받은 메시지를 파티션0의 세그먼트 로그 파일에 저장
3. 브로커의 세그먼트 로그 파일에 저장된 메시지는 컨슈머가 읽어갈 수 있음.

# 3.2 카프카의 핵심 개념
어떻게 높은 처리량, 빠른 응답 속도, 안정성을 얻을 수 있는가?

## 3.2.1 분산 시스템
주목표 : 
네트워크 상에서 연결된 컴퓨터들의 그룹. 단일 시스템이 갖지 못한 높은 성능이 목표

부목표 : 
서버 또는 노드에 장애 발생 시 다른 서버 또는 노드가 대응 -> 장애대응 탁월
부하가 높을 경우 -> 시스템 확장 용이

카프카의 경우 최초 구성 클러스터의 리소스가 한계일 경우 브로커를 추가하는 방향으로 확장 가능

## 3.2.2 페이지 캐시
직접 디스크에 읽고 쓰는 대신 물리 메모리 중 애플리케이션이 사용하지 않는 잔여 메모리 활용. 디스크I/O 접근이 줄어들므로 성능 높임
![](https://velog.velcdn.com/images/tngh147258/post/0e0e97ac-2f24-4b1b-b0b0-f81a76ed5c4d/image.png)
출처 : https://goodgid.github.io/Kafka-Design-Features/

## 3.2.3 배치 전송 처리
통신을 묶어 처리하면 네트워크 오버헤드를 줄일 수 있다. (크게 설명되지 않음)
ex) 상품 구매 프로세스에서 재고 수량 업데이트, 구매 로그 저장소 이동이 있다면 구매 로그 저장소 이동은 실시간 처리가 비교적 요구되지 않으니 배치 전송이 이득

## 3.2.4 압축 전송
압축으로 네트워크 대역폭 & 회선 비용 등 줄일 수 있음.
배치 전송과 결합하면 더욱 높은 효과 얻을 수 있음.
비슷한 파일 10-20개를 압축하는 것이 압축 효율이 더 높음

카프카 지원 압축 타입 : gzip, snappy, lz4, zstd 등
높은 압축률 : gzip, zstd
빠른 응답 속도 : lz4, snappy


## 3.2.5 토픽, 파티션, 오프셋
토픽 : 데이터 저장 위치 ex) 이메일 주소
병렬 처리를 위해 파티션이라는 단위로 다시 나뉨. 병렬처리로 인해 높은 처리량을 수행할 수 있음.

오프셋 : 파티션의 메시지가 저장되는 위치. 순차적으로 증가하는 숫자 형태 (배열의 index같은 느낌)
각 파티션의 오프셋은 고유함. 이를 통해 메시지 순서 보장 & 컨슈머에서는 마지막까지 읽은 위치 확인 가능.
![](https://velog.velcdn.com/images/tngh147258/post/36cefc4d-f377-4644-8efa-e90447ba0a26/image.png)
출처 : https://sookocheff.com/post/kafka/kafka-in-a-nutshell/



## 3.2.6 고가용성 보장
카프카는 분산 시스템 -> 하나의 서버 or 노드가 다운되어도 다른 서버 or 노드가 대신해 안정적 서비스 가능
이런 고가용성 보장 위해 리플리케이션 기능을 제공함

토픽 자체를 복제하는 것이 아니라 토픽의 파티션을 복제하는 것
토픽 생성 시 리플리케이션 팩터 수 지정 가능 & 숫자따라 리플리케이션이 존재하게 됨.

용어
원본 -> 리더, 리플리케이션 -> 팔로워

다만, 팔로워수가 많을 수록 안정적이고 좋은 것은 아님. 팔로워 수 만큼 브로커 디스크 공간 소비. 권장은 3

리더 : 프로듀서, 컨슈머로부터 오는 모든 읽기 & 쓰기 요청 처리.
팔로워 : 리더로부터 리플리케이션

## 3.2.7 주키퍼의 의존성
주키퍼는 여러 분산 애플리케이션에서 코디네이터 역할을 하는 애플리케이션

주키퍼는 여러 대 서버를 앙상블(클러스터)로 구성하고 살아 있는 노드 수가 과반수 이상이라면 지속적 서비스가 가능한 구조. 반드시 홀수로 구성

지노드를 이용해서 카프카의 메타 정보가 주키퍼에 기록됨
지노드를 이용해 브로커 노드 관리, 토픽 관리, 컨트롤러 관리 등 중요한 역할 수행

but. 성장하며 주키퍼 성능 한계 드러남 -> 주키퍼 의존성 제거 진행 -> 주키퍼 삭제된 카프카 버전 릴리즈

정리 : 카프카의 중요한 메타데이터를 저장하고 각 브로커를 관리하는 역할


# 3.3 프로듀서의 기본동작과 예제 맛보기

## 3.3.1 프로듀서 디자인
ProcuderRecord : 카프카로 전송하기 위한 실제 데이터
프로듀서 : 카프카로 레코드 전송
레코드 : 토픽, 파티션, 키, 밸류로 구성.
토픽과 밸류(메시지 내용) 필수. 
특정 파티션 지정하기 위한 레코드의 파티션 & 특정 파티션에 레코드들을 정렬하기 위한 레코드 키는 옵션



![](https://velog.velcdn.com/images/tngh147258/post/ccbbed9a-a7bf-46e0-9450-1c99877f7b66/image.png)
출처 : https://dzone.com/articles/take-a-deep-dive-into-kafka-producer-api


## 3.3.2 프로듀서의 주요 옵션

## 3.3.3 프로듀서 예제

# 3.4 컨슈머의 기본 동작과 예제 맛보기

## 3.4.1 컨슈머의 기본 동작

## 3.4.2 컨슈머의 주요 옵션

## 3.4.3 컨슈머 예제

## 3.4.4 컨슈머 그룹의 이해

# 3.5 정리
배치 전송, 페이지 캐시, 압축 사용 등으로 카프카는 높은 성능을 가지게 됨.
복습
- 컨슈머, 클라이언트의 기본 동작 & 주요 옵션 확인
- 프로듀서 & 컨슈머 통해 상황별로 어떻게 활용해야하는가
